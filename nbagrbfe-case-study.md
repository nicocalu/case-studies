# GPU‑Accelerated RBFE Mutation Pipeline (GROMACS + Python) — Case Study

TL;DR
- Built a GPU‑accelerated, scriptable RBFE pipeline around GROMACS and more tools to screen protein mutations (Nanobody–Antigen use case). It automates protein mutation, folding, docking, virtual screening, λ‑window scaffolding, pmx hybrid generation, TPR compilation, multi‑GPU window scheduling, and MBAR analysis to produce ΔΔG with errors.
- Core pieces of simulation live in gromacs/: initialization, launch, benchmarking, and analysis.

Context & scope
- Project : In-sillico pipeline that works with general protein-antibody systems that need affinity maturation.
- Repository scope: GPU‑offloaded GROMACS workflow (no Open MPI code in this snapshot). Scripts target a multi‑GPU node (MPS/oversubscription) and can be queued per‑mutation.
- Audience: computational structural biology workflows (RBFE) needing reproducible, multi‑GPU execution with simple CLI.

Problem & goals
- Problem: Manual, error‑prone setup for RBFE across many λ windows and two legs (complex/solvent) slows iteration and analysis.
- Goals:
  - One‑command scaffold for consistent λ schedules and MDPs.
  - Deterministic hybrid topology generation with pmx.
  - Turn‑key TPR compilation and GPU launch (oversubscribed windows/GPU).
  - MBAR‑based ΔΔG analysis with uncertainties.

High‑level workflow
0) Generate the mutations and screen them virutally
    - Use an ML-guided model to create the mutations (eg. efficient-evolution)
    - Fold the aminoacid chains into a 3D structure to validate the mutations (using a tools such as AlphaFold3)
    - Dock the proteins to validate the structure and their affinity potential (using HADDOCK)
    - Screen the mutations using heuristical tools (such as PRODIGY or PPI-Affinity)

1) Initialize mutation(s), λ windows, and MDP templates:
   - python3 [gromacs/scripts/init.py](gromacs/scripts/init.py) --mutations mutations.txt --profile quick|standard
     - Profiles define λ schedules and lengths (examples in code: QUICK/ STANDARD).
     - Writes mdp/ templates and per‑window mdps, and mutations/<MUT>/*/lambda_xx directories.
     - Generates windows.list assigning windows round‑robin to GPUs via [`init.write_windows_list`](gromacs/scripts/init.py).

2) Generate pmx hybrid topologies (one‑time per mutation and leg):
   - python3 [gromacs/scripts/make_hybrids.py](gromacs/scripts/make_hybrids.py) --mutations mutations.txt --wt-complex wt_complex --wt-solvent wt_solvent [--resid-map resid.tsv] [--run]
     - Handles chain vs numeric residue mapping via [`make_hybrids.build_mut_string`](gromacs/scripts/make_hybrids.py).
     - Optional residue map generated by: python3 [gromacs/scripts/make_resid.py](gromacs/scripts/make_resid.py) --pdb WT.pdb --out resid.tsv.

3) Compile TPRs for all λ:
   - bash [gromacs/scripts/grompp_all.sh](gromacs/scripts/grompp_all.sh) mutations/<MUT>

4) Optional micro‑benchmark and walltime estimate:
   - bash [gromacs/scripts/est_runtime.sh](gromacs/scripts/est_runtime.sh) mutations/<MUT> complex lambda_00 6

5) Run production windows on GPUs:
   - bash [gromacs/scripts/launch_rbfe.sh](gromacs/scripts/launch_rbfe.sh) mutations/<MUT>/windows.list
     - Uses GPU offload flags: -nb gpu -pme gpu -bonded gpu -update gpu.

6) Analyze ΔΔG (MBAR):
   - python3 [gromacs/scripts/analyze_ddg.py](gromacs/scripts/analyze_ddg.py) --root mutations
     - Per‑leg ΔG via [`analyze_ddg.leg_deltaG_kJ`](gromacs/scripts/analyze_ddg.py), ΔΔG = complex − solvent.

Architecture (this repo)
- Initialization and MDP generation
  - λ schedules and step counts live in [`init.MDP_BASE`](gromacs/scripts/init.py) and profile dictionaries (QUICK/ STANDARD).
  - Per‑window MDPs are materialized by [`init.init_mdp_templates`](gromacs/scripts/init.py) and [`init.make_lambda_dirs`](gromacs/scripts/init.py).
  - GPU scheduling list per mutation by [`init.write_windows_list`](gromacs/scripts/init.py).

- Hybrid topology generation (pmx)
  - Per‑mutation scripts are written (and optionally executed) by [`make_hybrids.main`](gromacs/scripts/make_hybrids.py).
  - Chain/numeric mapping helper: [`make_hybrids.build_mut_string`](gromacs/scripts/make_hybrids.py).
  - Residue map builder from WT PDB: [`make_resid.main`](gromacs/scripts/make_resid.py).

- TPR compilation and launch
  - TPRs for eq/prod across λ: [gromacs/scripts/grompp_all.sh](gromacs/scripts/grompp_all.sh).
  - GPU launch with oversubscription and MPS‑friendly flags: [gromacs/scripts/launch_rbfe.sh](gromacs/scripts/launch_rbfe.sh).

- Benchmark and analysis
  - Window micro‑benchmark + walltime projection: [gromacs/scripts/est_runtime.sh](gromacs/scripts/est_runtime.sh).
  - MBAR ΔΔG analysis with alchemlyb: [`analyze_ddg.main`](gromacs/scripts/analyze_ddg.py).

Key design decisions
- Fixed λ schedules per profile provide consistent overlap and analysis quality; see QUICK/ STANDARD lambdas in [`init`](gromacs/scripts/init.py).
- GPU offload everywhere practical in GROMACS mdrun (-nb/-pme/-bonded/-update gpu) to maximize device residency; see [gromacs/scripts/launch_rbfe.sh](gromacs/scripts/launch_rbfe.sh).
- Oversubscribe GPUs via CUDA MPS; default windows.list targets 6 windows/GPU across 8 GPUs (48 concurrent).
- MBAR estimator (alchemlyb) for robust ΔG with standard errors from dhdl decorrelated time series; see [`analyze_ddg`](gromacs/scripts/analyze_ddg.py).

Implementation highlights
- Scaffolding
  - Profiles define nsteps for eq/prod and λ arrays; see [`init.init_mdp_templates`](gromacs/scripts/init.py) and templates in mdp/.
  - Per‑window eq.mdp/prod.mdp include the correct init‑lambda‑state and λ arrays; see [`init.make_lambda_dirs`](gromacs/scripts/init.py).

- pmx integration
  - Mutations file format A33Y, B57F parsed by [`make_hybrids.parse_mutations`](gromacs/scripts/make_hybrids.py).
  - WT references per leg expected at wt_complex/ and wt_solvent/ (conf.gro, topol.top, include/*).

- Launch and analysis
  - Round‑robin window→GPU assignment by [`init.write_windows_list`](gromacs/scripts/init.py).
  - dhdl parsing and MBAR fit via alchemlyb in [`analyze_ddg.leg_deltaG_kJ`](gromacs/scripts/analyze_ddg.py), aggregated in [`analyze_ddg.main`](gromacs/scripts/analyze_ddg.py).

Repro steps (end‑to‑end)
- Prepare WT references:
  - wt_complex/{conf.gro, topol.top, include/*}
  - wt_solvent/{conf.gro, topol.top, include/*}

- Create mutations.txt:
  - A33Y
  - B57F

- Setup:
  - bash `setup.sh` (verify HPC SDK, CUDA, MPI, Gromacs compile, etc)

- Initialize:
  - python3 [gromacs/scripts/init.py](gromacs/scripts/init.py) --mutations mutations.txt --profile quick

- Generate hybrids (pmx):
  - python3 [gromacs/scripts/make_hybrids.py](gromacs/scripts/make_hybrids.py) --mutations mutations.txt --wt-complex wt_complex --wt-solvent wt_solvent --run

- Compile TPRs:
  - bash [gromacs/scripts/grompp_all.sh](gromacs/scripts/grompp_all.sh) mutations/A33Y

- Optional benchmark:
  - bash [gromacs/scripts/est_runtime.sh](gromacs/scripts/est_runtime.sh) mutations/A33Y complex lambda_00 6

- Launch:
  - bash [gromacs/scripts/launch_rbfe.sh](gromacs/scripts/launch_rbfe.sh) mutations/A33Y/windows.list

- Analyze:
  - python3 [gromacs/scripts/analyze_ddg.py](gromacs/scripts/analyze_ddg.py) --root mutations

Notes and caveats
- MPI: OpenMPI orchestration is WIP; current launch scripts are single‑node, multi‑GPU with MPS.
- pmx environment: Ensure pmx mutate is on PATH. If chain IDs vs numeric residues differ, generate a residue map with [`make_resid`](gromacs/scripts/make_resid.py).

Security & reproducibility
- Analysis relies on dhdl decorrelation and MBAR; see [`analyze_ddg`](gromacs/scripts/analyze_ddg.py) for details.
- Determinism: consistent λ grids and mdp templates are materialized per run for traceability.
- GPU settings: recommend enabling CUDA MPS on the node for oversubscription, using HPC SDK for tools such as NVSHMEM.

What’s next
- Integrate MPI scheduler (WIP branch) to orchestrate multi‑node runs.

One‑line resume extract
- Built a GPU‑accelerated nanobody-antigen affinity maturation pipeline (GROMACS + Python + ...) with automated λ‑window scaffolding, multi‑GPU scheduling, and MBAR analysis for ΔΔG
